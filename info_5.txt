git merge <сливаемая ветка>
Сливает изменения с переданной ветки в текущую.


--ff , --no-ff и --ff-only
Эти ключи определяют стратегию слияния. 
Подробнее о стратегиях мы поговорим чуть 
ниже, а пока перечислим назначения каждого 
из ключей.
--ff – включить fast-forward, если это 
возможно,
--no-ff – отключить fast-forward,
а --ff-only – остановить merge, если его 
невозможно сделать fast-forward.

--abort
Ключ, использующийся только при разрешении 
конфликтов. Позволяет прервать слияние и 
вернуть все к моменту начала операции.

--continue
Ключ, использующийся только при разрешении 
конфликтов. Позволяет продолжить слияние 
после разрешения всех конфликтов.



Стратегия слияния – это набор правил, которыми 
руководствуется Git при выполнении слияния.
Существует две основных стратегии слияния:
Явное слияние
Неявное слияние.
Их различие заключается в том, что при явном всегда создается 
новый коммит, а при неявном – используются существующие коммиты.



Во время явного слияния создается так называемый merge-коммит. 
Основное предназначение этого коммита состоит в том, чтобы 
"соединить" изменения двух веток. У этого коммита есть одна 
особенность: два родительских коммита. Один родитель – последний 
коммит сливаемой ветки, второй – последний коммит целевой ветки.
Это NOT FAST-forward



Во время неявного слияния не создается новых коммитов: 
используются только уже существующие. Суть этого слияния 
заключается в том, что из вливаемой ветки извлекаются несколько 
коммитов, а затем они применяются к последнему коммиту целевой 
ветки. Такое слияние называется fast-forward.


И прикол в том что допустим если у нас 
коммиты c1 и c2 в ветке main,
Затем у нас 3 коммита сделанные в ветке develop(c3,c4,c5)
и мы переключаемся на ветку main затем делаем fast-forward
и получается что это все становится одной веткой 
и теперь у нас одна ветка и ее последний коммит в котором
обьеденены все изменения это c5

Этот вид слияния будет невозможен если у нас будет еще один
коммит в main ветке который будет после создания ветки develop.
Так как тогда вся информация об этом коммите будет полностью
потеряна







Очень часто во время слияния веток оказывается, что ваши 
изменения удаляют или переписывают информацию в уже существующих 
файлах. Такая ситуация называется файловым конфликтом. Git 
останавливает выполнение слияния, пока вы не разрешите конфликт.

По сути, Git сталкивается с проблемой: у него есть два файла с 
одним и тем же именем, и он не знает, какой из них взять. 
Поэтому обращается к нам за помощью.






Общий подход к разрешению конфликтов такой:
Непосредственно разрешить конфликт одним из двух рассмотренных 
немного ниже способов. Либо, если возникновение конфликта стало 
неожиданным для вас, можно выполнить git merge --abort. Эта 
команда прервет слияние и вернет все, как было.
Сообщить Git, что мы разрешили конфликт, добавив все файлы с 
разрешенными конфликтами в индекс. Сделать это можно уже 
знакомой командой git add <конфликтный файл> для каждого 
конфликтного файла.
Продолжить слияние, выполнив git merge --continue. Либо вручную 
создать merge-коммит уже знакомой командой git commit.







Выше мы уже сказали, что существует два способа разрешать 
конфликты, вот они:

Первый способ. Разрешить конфликт вручную. Тогда мы можем 
самостоятельно изменить конфликтные файлы, сделав их такими, 
какими мы хотим их видеть.
Второй способ. Просто выбрать один из двух файлов.




РУЧНОЕ РАЗРЕШЕНИЕ КОНФЛИКТА 

Для этого в любом текстовом редакторе откройте конфликтный файл
Допустим у нас содержимое следующее

- This is documentation
<<<<<<< HEAD
- It contains lots of info
=======
- New feature info
- It has lots of info
>>>>>>> develop

Видим, что Git оставил нам пометки, чтобы нам было проще 
устранять конфликт:
Текст до <<<<<<< HEAD – это общая часть двух файлов, она 
не конфликтует. В нашем случае оба файла имеют одинаковую 
первую строку: - This is documentation
Текст между <<<<<<< HEAD и ======= – это конфликтующее с
одержимое файла, на который указывает HEAD, то есть файла 
из целевой ветки. В нашем случае это вторая строка, именно 
она переписывается изменениями из ветки develop.
Все, что находится между ======= и >>>>>>> develop – это 
содержимое файла из ветки develop. В нашем случае это вторая 
и третья строки: - New feature info и - It has lots of info.



Наша задача – объяснить Git, каким мы хотим видеть файл Docs.md.
Для этого нам нужно вручную отредактировать файл Docs.md. Нам не 
обязательно выбирать один из двух приведенных вариантов – в этом 
вся прелесть ручного редактирования. Мы можем удалить вообще 
весь текст из файла, оставить часть первого файла и часть второго 
или вообще написать что-то свое. Не забудьте удалить строки, 
которые оставил Git, то есть 
<<<<<<< HEAD, ======= и >>>>>>>develop, сами собой они не 
пропадут. В качестве примера, мы отредактировали конфликтный 
файл таким образом:
- This is documentation
- It contains lots of info
- New feature info







ВТОРОЙ СПОСОБ РЕШЕНИЯ КОНФЛИКТА


Если вы точно знаете, что вам нужно оставить только один из 
двух конфликтных файлов (вся информация из другого файла при 
этом потеряется), можно сказать об этом Git:
Выполните git checkout --ours Docs.md, чтобы выбрать файл ветки 
main (то есть целевой ветки)
Либо git checkout --their Docs.md, чтобы выбрать файл из ветки 
develop (то есть сливаемой ветки).








*это типо доп способ решения проблемы если ты не ебешь что нужно оставлять*
База слияния – это последний общий родитель конфликтных файлов. 
Говоря проще, это тот файл, применив к которому изменения из 
Дельты-1, мы получим наш файл в ветке develop, а применив 
изменения из Дельты-2, мы получим наш файл в ветке main. Именно 
база слияния является для нас самым важным состоянием при 
разрешении конфликта. Мы можем просмотреть ее, и это сильно 
поможет нам в понимании, какой из файлов нужно оставить.








git rebase

ключи

-i
--interative
Эти ключи позволяют нам делать rebase в интерактивном режиме.
Мы будем активно пользоваться ими при редактировании старых 
коммитов.

--abort
Ключ, использующийся только при разрешении конфликтов. Позволяет 
прервать ребейз и вернуть все к моменту до начала операции.

--continue
Ключ, использующийся только при разрешении конфликтов. Позволяет 
продолжить ребейз после разрешения всех конфликтов.

--skip
Ключ, использующийся только при разрешении конфликтов. Позволяет 
пропустить текущий коммит.



Итак, давайте познакомимся с командой git rebase. Она позволит 
нам не только объединять изменения с разных веток, но и менять 
историю репозитория, манипулируя коммитами.

Если говорить кратко, git rebase переносит коммиты текущей ветки 
на вершину переданной. Но перед тем, как перейти непосредственно 
к команде, давайте разберем принцип ее действия на примере.

    
   main
    |
A-B-C
  |
  --D-E-F
        |
     develop


Допустим у нас такая история коммитов в которой очевидно
fast-forward применить не получиться


Если вы примените команду git rebase main, находясь на ветке 
develop, репозиторий примет следующий вид.

   main
    |
A-B-C
    |
    --Dnew-Enew-Fnew
          |
        develop


То есть команда git rebase перенесла коммиты ветки develop так, 
чтобы ветка develop брала свое начало на последнем коммите main. 
Попросту говоря, она перенесла коммиты ветки develop на вершину 
ветки main. Такое состояние очень выгодно нам тем, что в нем уже 
можно сделать fast-forward слияние. Таким образом, мы избавились 
от необходимости создания merge-коммита.
Указатель ORIG-HEAD останеться на оригинальном коммите FAST

Если rebase еще не закончился то отменить его легко можно
с помощью git rebase --abort

Если он уже завершет то благодаря оставленному указателю все
равно легко отматать все назад git reset --hard ORIG_HEAD



На самом деле git rebase можно выполнять для одной и той же 
ветки. В обычном режиме это нам ничего не даст, но вот в 
интерактивном режиме мы сможем поменять сообщения, содержимое 
и вообще манипулировать коммитами, как нам только вздумается, 
вплоть до удаления. Давайте на примере разберем, как происходит 
изменение коммитов. Итак, допустим у нас есть репозиторий, граф 
которого выглядит так:
A-B-C-D-E

Допустим, нам нужно поменять сообщение коммита C. Как это 
сделать? Давайте попробуем взять все коммиты, начиная с коммита 
С и заканчивая коммитом Е, и перенести их на вершину той же 
ветки. Если бы мы не меняли сообщение коммита С, то такая 
манипуляция ничего не изменила бы. В этом и кроется небольшая 
хитрость: если мы поменяем коммит С, поменяется его хеш-сумма, 
и, соответственно, нам придется менять все последующие коммиты. 
А теперь вспомним, как работает rebase. На каждом шаге она заново 
вычисляет дельту и создает новый коммит на основе старого. 
Именно то, что нам нужно. Давайте поменяем сообщение коммита С. 
Для этого выполним:
git rebase -i HEAD~3


Заметьте, мы указываем все коммиты не с коммита C, а с 
коммита B. Если бы мы указали коммиты, начиная с коммита 
C, git rebase определил бы коммит C, как общий коммит ветки 
main и нашей подвыборки коммитов, а значит сам коммит C 
меняться бы не стал. Поэтому нужно указать коммит за один до 
того, который мы хотим изменить.
После выполнения команды откроется TO-DO файл rebase


Все доступные команды можно посмотреть в документации, мы же 
разберем только те, которые необходимы, чтобы изменять коммиты:
p, pick <коммит> – просто использовать коммит, ничего не менять
r, reword <коммит> – использовать коммит, но поменять его 
сообщение
e, edit <коммит> – использовать коммит, но остановить ребейз, 
чтобы добавить в коммит больше файлов
s, squash <коммит> – использовать коммит, объединив его с 
предыдущим
f, fixup <коммит> – как squash, но удаляет информацию об 
объединенном коммите из истории.


В нашем случае, если мы хотим поменять сообщение коммита С, 
нужно отредактировать файл следующим образом:
reword f831285 C
pick c06b382 D
pick 0874316 E


То есть мы заменили команду pick на reword напротив коммита С. 
Сохраняем файл и выходим обратно в консоль. Перед нами сразу же 
откроется редактор сообщения коммита С. Вводим новое сообщение, 
сохраняем файл и выходим из редактора. Если мы теперь просмотрим 
историю, то обнаружим, что сообщение коммита С действительно 
поменялось, а вместе с ним поменялись и хэши последующих коммитов. 
Аналогичным образом можно объединять и удалять любые коммиты, а 
также добавлять в них новые файлы.












git cherry-pick <хеш коммита>
git cherry-pick <хеш первого коммита> … <хеш последнего коммита>

иногда возникает ситуация, когда изменения внесенные другим 
разработчиком в своей ветке нужны вам в вашей ветке прямо 
сейчас. Конечно, можно сделать merge, но это только засорит 
историю и сломает логику репозитория: зачем делать слияние, 
если ветка другого разработчика еще к нему не готова. В этом 
случае нам на помощь придет команда git cherry-pick. Давайте 
разберемся, как ей пользоваться, а затем подробнее разберем, в 
каких именно случаях лучше всего применять cherry-pick, а в 
каких merge.


Берет переданный коммит и создает в текущей ветке его точную копию.

Также в команду можно передать первый и последний коммит 
последовательности, тогда та же операция будет выполнена 
для всех коммитов последовательности.



-e
--edit
С этим ключом вы сможете отредактировать сообщение коммита.

-n
--no-commit
С этим ключом команда не создаст коммит на вашей ветке, 
а только скопирует все изменения в вашу рабочую копию. Т
о есть с этим ключом данная команда идентичная 
git checkout <коммит> *

--abort
Ключ, использующийся только при разрешении конфликтов. 
Позволяет прервать операцию и вернуть все к моменту до 
начала операции.

--continue
Ключ, использующийся только при разрешении конфликтов. 
Позволяет продолжить операцию после разрешения всех конфликтов.




